# Real-Valued Basic Functions

This chapter describes built-in functions that take zero or more real
or integer arguments and return real values.

## Vectorization of Real-Valued Functions {#fun-vectorization}

Although listed in this chapter, many of Stan's built-in functions are
vectorized so that they may be applied to any argument type.  The
vectorized form of these functions is not any faster than writing an
explicit loop that iterates over the elements applying the
function---it's just easier to read and write and less error prone.

### Unary Function Vectorization

Many of Stan's unary functions can be applied to any argument type.
For example, the exponential function, `exp`, can be applied to `real`
arguments or arrays of `real` arguments.  Other than for integer
arguments, the result type is the same as the argument type, including
dimensionality and size.  Integer arguments are first promoted to real
values, but the result will still have the same dimensionality and
size as the argument.

#### Real and real array arguments

When applied to a simple real value, the result is a real value.  When
applied to arrays, vectorized functions like `exp()` are defined
elementwise.  For example,

```
 // declare some variables for arguments
 real x0;
 real x1[5];
 real x2[4, 7];
 ...
 // declare some variables for results
 real y0;
 real y1[5];
 real y2[4, 7];
 ...
 // calculate and assign results
 y0 = exp(x0);
 y1 = exp(x1);
 y2 = exp(x2);
 ```

When `exp` is applied to an array, it applies elementwise.  For
example, the statement above,

```
 y2 = exp(x2);
 ```

produces the same result for `y2` as the explicit loop

```
 for (i in 1:4)
   for (j in 1:7)
     y2[i, j] = exp(x2[i, j]);
 ```

#### Vector and matrix arguments

Vectorized functions also apply elementwise to vectors and matrices.
For example,

```
 vector[5] xv;
 row_vector[7] xrv;
 matrix[10, 20] xm;
 
 vector[5] yv;
 row_vector[7] yrv;
 matrix[10, 20] ym;
 
 yv = exp(xv);
 yrv = exp(xrv);
 ym = exp(xm);
 ```

Arrays of vectors and matrices work the same way.  For example,

```
 matrix[17, 93] u[12];
 
 matrix[17, 93] z[12];
 
 z = exp(u);
 ```

After this has been executed, `z[i, j, k]` will be equal to `exp(u[i,
j, k])`.

#### Integer and integer array arguments

Integer arguments are promoted to real values in vectorized unary
functions.  Thus if `n` is of type `int`, `exp(n)` is of type `real`.
Arrays work the same way, so that if `n2` is a one dimensional array
of integers, then `exp(n2)` will be a one-dimensional array of reals
with the same number of elements as `n2`.  For example,

```
 int n1[23];
 real z1[23];
 z1 = exp(n1);
 ```

It would be illegal to try to assign `exp(n1)` to an array of
integers; the return type is a real array.

## Mathematical Constants {#built-in-constants}

Constants are represented as functions with no arguments and must be
called as such.  For instance, the mathematical constant $\pi$ must be
written in a Stan program as `pi()`.

<!-- pi -->
<!-- real; pi; () -->

`real` **`pi`**()
 $\pi$, the ratio of a circle's circumference to its diameter

<!-- e -->
<!-- real; e; () -->

`real` **`e`**()
 $e$, the base of the natural logarithm

<!-- sqrt2 -->
<!-- real; sqrt2; () -->

`real` **`sqrt2`**()
 The square root of 2

<!-- log2 -->
<!-- real; log2; () -->

`real` **`log2`**()
 The natural logarithm of 2

<!-- log10 -->
<!-- real; log10; () -->

`real` **`log10`**()
 The natural logarithm of 10

## Special Values

<!-- not_a_number -->
<!-- real; not_a_number; () -->

`real` **`not_a_number`**()
 Not-a-number, a special non-finite real value returned to signal an
error

<!-- positive_infinity -->
<!-- real; positive_infinity; () -->

`real` **`positive_infinity`**()
 Positive infinity, a special non-finite real value larger than all
finite numbers

<!-- negative_infinity -->
<!-- real; negative_infinity; () -->

`real` **`negative_infinity`**()
 Negative infinity, a special non-finite real value smaller than all
finite numbers

<!-- machine_precision -->
<!-- real; machine_precision; () -->

`real` **`machine_precision`**()
 The smallest number $x$ such that $(x + 1) \neq 1$ in floating-point
arithmetic on the current hardware platform

## Log Probability Function {#get-log-prob}

The basic purpose of a Stan program is to compute a log probability
function and its derivatives.  The log probability function in a Stan
model outputs the log density on the unconstrained scale.  A log
probability accumulator starts at zero and is then incremented in
various ways by a Stan program.  The variables are first transformed
from unconstrained to constrained, and the log Jacobian determinant
added to the log probability accumulator.  Then the model block is
executed on the constrained parameters, with each sampling statement
(`~`) and log probability increment statement (`increment_log_prob`)
adding to the accumulator.  At the end of the model block execution,
the value of the log probability accumulator is the log probability
value returned by the Stan program.

Stan provides a special built-in function `target()` that takes no
arguments and returns the current value of the log probability
accumulator.[^fn_lp]  This function is primarily useful for debugging
purposes, where for instance, it may be used with a print statement to
display the log probability accumulator at various stages of execution
to see where it becomes ill defined.

[^fn_lp]: This function used to be called `get_lp()`, but that   name
has been deprecated; using it will print a warning.  The   function
`get_lp()` will be removed in a future release.

<!-- target -->
<!-- real; target; () -->

`real` **`target`**()
 Returns the current value of the log probability accumulator.

<!-- get_lp -->
<!-- real; get_lp; () -->

`real` **`get_lp`**()
 Returns the current value of the log probability accumulator;
**deprecated;** - use `target()` instead.

Both `target` and the deprecated `get_lp` act like other functions
ending in `_lp`, meaning that they may only may only be used in the
model block.

## Logical Functions

Like C++, BUGS, and R, Stan uses 0 to encode false, and 1 to encode
true.  Stan supports the usual boolean comparison operations and
boolean operators.  These all have the same syntax and precedence as
in  C++; for the full list of operators and precedences, see the
reference manual.

### Comparison Operators

All comparison operators return boolean values, either 0 or 1.  Each
operator has two signatures, one for integer comparisons and one for
floating-point comparisons.  Comparing an integer and real value is
carried out by first promoting the integer value.

<!-- operator_logical_less_than -->
<!-- int; operator<; (int x, int y); -->

`int` **`operator<`**(`int x, int y`)


<!-- int; operator<; (real x, real y); -->

`int` **`operator<`**(`real x, real y`)
 Returns 1 if x is less than y and 0 otherwise. \[
\text{operator<}(x,y) = \begin{cases} 1 & \text{if $x < y$} \\ 0 &
\text{otherwise} \end{cases} \]

<!-- operator_logical_less_than_equal -->
<!-- int; operator<=; (int x, int y); -->

`int` **`operator<=`**(`int x, int y`)


<!-- int; operator<=; (real x, real y); -->

`int` **`operator<=`**(`real x, real y`)
 Returns 1 if x is less than or equal y and 0 otherwise. \[
\text{operator<=}(x,y) = \begin{cases} 1 & \text{if $x \leq y$} \\ 0 &
\text{otherwise} \end{cases} \]

<!-- operator_logical_greater_than -->
<!-- int; operator>; (int x, int y); -->

`int` **`operator>`**(`int x, int y`)


<!-- int; operator>; (real x, real y); -->

`int` **`operator>`**(`real x, real y`)
 Returns 1 if x is greater than y and 0 otherwise. \[ \text{operator>}
= \begin{cases} 1 & \text{if $x > y$} \\ 0 & \text{otherwise}
\end{cases} \]

<!-- operator_logical_greater_than_equal -->
<!-- int; operator>=; (int x, int y); -->

`int` **`operator>=`**(`int x, int y`)


<!-- int; operator>=; (real x, real y); -->

`int` **`operator>=`**(`real x, real y`)
 Returns 1 if x is greater than or equal to y and 0 otherwise. \[
\text{operator>=} = \begin{cases} 1 & \text{if $x \geq y$} \\ 0 &
\text{otherwise} \end{cases} \]

<!-- operator_logial_equal -->
<!-- int; operator==; (int x, int y); -->

`int` **`operator==`**(`int x, int y`)


<!-- int; operator==; (real x, real y); -->

`int` **`operator==`**(`real x, real y`)
 Returns 1 if x is equal to y and 0 otherwise. \[
\text{operator==}(x,y) = \begin{cases} 1 & \text{if $x = y$} \\ 0 &
\text{otherwise} \end{cases} \]

<!-- operator_logical_not_equal -->
<!-- int; operator!=; (int x, int y); -->

`int` **`operator!=`**(`int x, int y`)


<!-- int; operator!=; (real x, real y); -->

`int` **`operator!=`**(`real x, real y`)
 Returns 1 if x is not equal to y and 0 otherwise. \[
\text{operator!=}(x,y) = \begin{cases} 1 & \text{if $x \neq y$} \\ 0 &
\text{otherwise} \end{cases} \]

### Boolean Operators

Boolean operators return either 0 for false or 1 for true.  Inputs may
be any real or integer values, with non-zero values being treated as
true and zero values treated as false.  These operators have the usual
precedences, with negation (not) binding the most tightly, conjunction
the next and disjunction the weakest; all of the operators bind more
tightly than the comparisons.  Thus an expression such as `!a && b` is
interpreted as `(!a) && b`, and `a < b || c >= d && e != f` as `(a <
b) || (((c >= d) && (e != f)))`.

<!-- operator_negation -->
<!-- int; operator!; (int x); -->

`int` **`operator!`**(`int x`)


<!-- int; operator!; (real x); -->

`int` **`operator!`**(`real x`)
 Returns 1 if x is zero and 0 otherwise. \[ \text{operator!}(x) =
\begin{cases} 0 & \text{if $x \neq 0$} \\ 1 & \text{if $x = 0$}
\end{cases} \]

<!-- operator_logical_and -->
<!-- int; operator&&; (int x, int y); -->

`int` **`operator&&`**(`int x, int y`)


<!-- int; operator&&; (real x, real y); -->

`int` **`operator&&`**(`real x, real y`)
 Returns 1 if x is unequal to 0 and y is unequal to 0. \[
\mathrm{operator\&\&}(x,y) = \begin{cases} 1 & \text{if $x \neq 0$}
\text{ and } y \neq 0\\ 0 & \text{otherwise} \end{cases} \]

<!-- operator_logical_or -->
<!-- int; operator||; (int x, int y); -->

`int` **`operator||`**(`int x, int y`)


<!-- int; operator||; (real x, real y); -->

`int` **`operator||`**(`real x, real y`)
 Returns 1 if x is unequal to 0 or y is unequal to 0. \[
\text{operator||}(x,y) = \begin{cases} 1 & \text{if $x \neq 0$}
\textrm{ or } y \neq 0\\ 0 & \text{otherwise} \end{cases} \]

#### Boolean Operator Short Circuiting

Like in  C++, the boolean operators `&&` and `||` and are implemented
to short circuit directly to a return value after evaluating the first
argument if it is sufficient to resolve the result.  In evaluating `a
|| b`, if `a` evaluates to a value other than zero, the expression
returns the value 1 without evaluating the expression `b`.  Similarly,
evaluating `a && b` first evaluates `a`, and if the result is zero,
returns 0 without evaluating `b`.

### Logical Functions

The logical functions introduce conditional behavior functionally and
are primarily provided for compatibility with BUGS and JAGS.

<!-- step -->
<!-- real; step; (real x); -->

`real` **`step`**(`real x`)
 Returns 1 if x is positive and 0 otherwise. \[ \text{step}(x) =
\begin{cases} 0 & \text{if } x < 0 \\ 1 & \text{otherwise} \end{cases}
\] _**Warning:**_ `int_step(0)` and `int_step(NaN)` return 0 whereas
`step(0)` and `step(NaN)` return 1.

The step function is often used in BUGS to perform conditional
operations.  For instance, `step(a-b)` evaluates to 1 if `a` is
greater than `b` and evaluates to 0 otherwise. `step` is a step-like
functions; see the warning in section \@ref(step-functions) applied to
expressions dependent on parameters.

<!-- is_inf -->
<!-- int; is_inf; (real x); -->

`int` **`is_inf`**(`real x`)
 Returns 1 if x is infinite (positive or negative) and 0 otherwise. 

<!-- is_nan -->
<!-- int; is_nan; (real x); -->

`int` **`is_nan`**(`real x`)
 Returns 1 if x is NaN and 0 otherwise. 

Care must be taken because both of these indicator functions are
step-like and thus can cause discontinuities in gradients when applied
to parameters; see section \@ref(step-functions) for details.

## Real-Valued Arithmetic Operators {#real-valued-arithmetic-operators}

The arithmetic operators are presented using  C++ notation.  For
instance `operator+(x,y)` refers to the binary addition operator and
`operator-(x)` to the unary negation operator.  In Stan programs,
these are written using the usual infix and prefix notations as `x +
y` and `-x`, respectively.

### Binary Infix Operators

<!-- operator_add -->
<!-- real; operator+; (real x, real y); -->

`real` **`operator+`**(`real x, real y`)
 Returns the sum of x and y. \[ (x + y) = \text{operator+}(x,y) = x+y
\]

<!-- operator_subtract -->
<!-- real; operator-; (real x, real y); -->

`real` **`operator-`**(`real x, real y`)
 Returns the difference between x and y. \[ (x - y) =
\text{operator-}(x,y) = x - y \]

<!-- operator_multiply -->
<!-- real; operator*; (real x, real y); -->

`real` **`operator*`**(`real x, real y`)
 Returns the product of x and y. \[ (x * y) = \text{operator*}(x,y) =
xy \]

<!-- operator_divide -->
<!-- real; operator/; (real x, real y); -->

`real` **`operator/`**(`real x, real y`)
 Returns the quotient of x and y. \[ (x / y) = \text{operator/}(x,y) =
\frac{x}{y} \]

<!-- operator_pow -->
<!-- real; operator^; (real x, real y); -->

`real` **`operator^`**(`real x, real y`)
 Return x raised to the power of y. \[ (x^\mathrm{\wedge}y) =
\text{operator}^\mathrm{\wedge}(x,y) = x^y \]

### Unary Prefix Operators

<!-- operator_subtract -->
<!-- real; operator-; (real x); -->

`real` **`operator-`**(`real x`)
 Returns the negation of the subtrahend x. \[ \text{operator-}(x) =
(-x) \]

<!-- operator_add -->
<!-- real; operator+; (real x); -->

`real` **`operator+`**(`real x`)
 Returns the value of x. \[ \text{operator+}(x) = x \]

## Step-like Functions {#step-functions}

_**Warning:**_  *These functions can seriously hinder sampling and
optimization efficiency for gradient-based methods (e.g., NUTS, HMC,
BFGS) if applied to parameters (including transformed parameters and
local variables in the transformed parameters or model block).  The
problem is that they break gradients due to discontinuities coupled
with   zero gradients elsewhere.  They do not hinder sampling when
used in the   data, transformed data, or generated quantities blocks.*

### Absolute Value Functions

<!-- fabs -->
<!-- R; fabs; (T x); -->

`R` **`fabs`**(`T x`)
absolute value of x

<!-- abs -->
<!-- real; abs; (real x); -->

`real` **`abs`**(`real x`)
 Returns the absolute value of x, defined by \[ \text{abs}(x) = |x| \]
See the warning at start of section \@ref(step-functions) for
application to parameters.

<!-- int; abs; (int x); -->

`int` **`abs`**(`int x`)
 Returns the absolute value of x, defined by \[ \text{abs}(x) = |x| \]

<!-- fdim -->
<!-- real; fdim; (real x, real y); -->

`real` **`fdim`**(`real x, real y`)
 Returns the positive difference between x and y, which is x - y if x
is greater than y and 0 otherwise; see warning at start of section
\@ref(step-functions). \[ \text{fdim}(x,y) = \begin{cases} x-y &
\text{if } x \geq y \\ 0 & \text{otherwise} \end{cases} \]

### Bounds Functions

<!-- fmin -->
<!-- real; fmin; (real x, real y); -->

`real` **`fmin`**(`real x, real y`)
 Returns the minimum of x and y; see warning at start of section
\@ref(step-functions). \[ \text{fmin}(x,y) = \begin{cases} x &
\text{if } x \leq y \\ y & \text{otherwise} \end{cases} \]

<!-- fmax -->
<!-- real; fmax; (real x, real y); -->

`real` **`fmax`**(`real x, real y`)
 Returns the maximum of x and y; see warning at start of section
\@ref(step-functions). \[ \text{fmax}(x,y) = \begin{cases} x &
\text{if } x \geq y \\ y & \text{otherwise} \end{cases} \]

### Arithmetic Functions

<!-- fmod -->
<!-- real; fmod; (real x, real y); -->

`real` **`fmod`**(`real x, real y`)
 Returns the real value remainder after dividing x by y; see warning
at start of section \@ref(step-functions). \[ \text{fmod}(x,y) = x -
\left\lfloor \frac{x}{y} \right\rfloor \, y \] The operator $\lfloor u
\rfloor$ is the floor operation; see below.

### Rounding Functions

_**Warning:**_  Rounding functions convert real values to integers.
Because the output is an integer, any gradient information resulting
from functions applied to the integer is not passed to the real value
it was derived from.  With MCMC sampling using HMC or NUTS, the MCMC
acceptance procedure will correct for any error due to poor gradient
calculations, but the result is likely to be reduced acceptance
probabilities and less efficient sampling.

The rounding functions cannot be used as indices to arrays because
they return real values.  Stan may introduce integer-valued versions
of these in the future, but as of now, there is no good workaround.

<!-- floor -->
<!-- R; floor; (T x); -->

`R` **`floor`**(`T x`)
floor of x, which is the largest integer less than or equal to x,
converted to a real value; see warning at start of section
\@ref(step-functions)

<!-- ceil -->
<!-- R; ceil; (T x); -->

`R` **`ceil`**(`T x`)
ceiling of x, which is the smallest integer greater than or equal to
x, converted to a real value; see warning at start of section
\@ref(step-functions)

<!-- round -->
<!-- R; round; (T x); -->

`R` **`round`**(`T x`)
nearest integer to x, converted to a real value; see warning at start
of section \@ref(step-functions)

<!-- trunc -->
<!-- R; trunc; (T x); -->

`R` **`trunc`**(`T x`)
integer nearest to but no larger in magnitude than x, converted to a
double value; see warning at start of section \@ref(step-functions)

## Power and Logarithm Functions

<!-- sqrt -->
<!-- R; sqrt; (T x); -->

`R` **`sqrt`**(`T x`)
square root of x

<!-- cbrt -->
<!-- R; cbrt; (T x); -->

`R` **`cbrt`**(`T x`)
cube root of x

<!-- square -->
<!-- R; square; (T x); -->

`R` **`square`**(`T x`)
square of x

<!-- exp -->
<!-- R; exp; (T x); -->

`R` **`exp`**(`T x`)
natural exponential of x

<!-- exp2 -->
<!-- R; exp2; (T x); -->

`R` **`exp2`**(`T x`)
base-2 exponential of x

<!-- log -->
<!-- R; log; (T x); -->

`R` **`log`**(`T x`)
natural logarithm of x

<!-- log2 -->
<!-- R; log2; (T x); -->

`R` **`log2`**(`T x`)
base-2 logarithm of x

<!-- log10 -->
<!-- R; log10; (T x); -->

`R` **`log10`**(`T x`)
base-10 logarithm of x

<!-- pow -->
<!-- real; pow; (real x, real y); -->

`real` **`pow`**(`real x, real y`)
 Returns x raised to the power of y. \[ \text{pow}(x,y) = x^y \]

<!-- inv -->
<!-- R; inv; (T x); -->

`R` **`inv`**(`T x`)
inverse of x

<!-- inv_sqrt -->
<!-- R; inv_sqrt; (T x); -->

`R` **`inv_sqrt`**(`T x`)
inverse of the square root of x

<!-- inv_square -->
<!-- R; inv_square; (T x); -->

`R` **`inv_square`**(`T x`)
inverse of the square of x

## Trigonometric Functions

<!-- hypot -->
<!-- real; hypot; (real x, real y); -->

`real` **`hypot`**(`real x, real y`)
 Returns the length of the hypotenuse of a right triangle with sides
of length x and y. \[ \text{hypot}(x,y) = \begin{cases} \sqrt{x^2+y^2}
& \text{if } x,y\geq 0 \\ \textrm{NaN} & \text{otherwise} \end{cases}
\]

<!-- cos -->
<!-- R; cos; (T x); -->

`R` **`cos`**(`T x`)
cosine of the angle x (in radians)

<!-- sin -->
<!-- R; sin; (T x); -->

`R` **`sin`**(`T x`)
sine of the angle x (in radians)

<!-- tan -->
<!-- R; tan; (T x); -->

`R` **`tan`**(`T x`)
tangent of the angle x (in radians)

<!-- acos -->
<!-- R; acos; (T x); -->

`R` **`acos`**(`T x`)
principal arc (inverse) cosine (in radians) of x

<!-- asin -->
<!-- R; asin; (T x); -->

`R` **`asin`**(`T x`)
principal arc (inverse) sine (in radians) of x

<!-- atan -->
<!-- R; atan; (T x); -->

`R` **`atan`**(`T x`)
principal arc (inverse) tangent (in radians) of x, with values from
$-\pi$ to $\pi$

<!-- atan2 -->
<!-- real; atan2; (real y, real x); -->

`real` **`atan2`**(`real y, real x`)
 Returns the principal arc (inverse) tangent (in radians) of y divided
by x, \[ \text{atan2}(y, x) = \arctan\left(\frac{y}{x}\right) \]

## Hyperbolic Trigonometric Functions

<!-- cosh -->
<!-- R; cosh; (T x); -->

`R` **`cosh`**(`T x`)
hyperbolic cosine of x (in radians)

<!-- sinh -->
<!-- R; sinh; (T x); -->

`R` **`sinh`**(`T x`)
hyperbolic sine of x (in radians)

<!-- tanh -->
<!-- R; tanh; (T x); -->

`R` **`tanh`**(`T x`)
hyperbolic tangent of x (in radians)

<!-- acosh -->
<!-- R; acosh; (T x); -->

`R` **`acosh`**(`T x`)
inverse hyperbolic cosine (in radians)

<!-- asinh -->
<!-- R; asinh; (T x); -->

`R` **`asinh`**(`T x`)
inverse hyperbolic cosine (in radians)

<!-- atanh -->
<!-- R; atanh; (T x); -->

`R` **`atanh`**(`T x`)
inverse hyperbolic tangent (in radians) of x

## Link Functions {#link-functions}

The following functions are commonly used as link functions in
generalized linear models.  The function $\Phi$ is also commonly used
as a link function (see section \@ref(Phi-function)).

<!-- logit -->
<!-- R; logit; (T x); -->

`R` **`logit`**(`T x`)
log odds, or logit, function applied to x

<!-- inv_logit -->
<!-- R; inv_logit; (T x); -->

`R` **`inv_logit`**(`T x`)
logistic sigmoid function applied to x

<!-- inv_cloglog -->
<!-- R; inv_cloglog; (T x); -->

`R` **`inv_cloglog`**(`T x`)
inverse of the complementary log-log function applied to x

## Probability-Related Functions {#Phi-function}

### Normal Cumulative Distribution Functions

The error function `erf` is related to the standard normal cumulative
distribution function $\Phi$ by scaling.  See section
\@ref(normal-distribution) for the general normal cumulative
distribution function (and its complement).

<!-- erf -->
<!-- R; erf; (T x); -->

`R` **`erf`**(`T x`)
error function, also known as the Gauss error function, of x

<!-- erfc -->
<!-- R; erfc; (T x); -->

`R` **`erfc`**(`T x`)
complementary error function of x

<!-- Phi -->
<!-- R; Phi; (T x); -->

`R` **`Phi`**(`T x`)
standard normal cumulative distribution function of x

<!-- inv_Phi -->
<!-- R; inv_Phi; (T x); -->

`R` **`inv_Phi`**(`T x`)
standard normal inverse cumulative distribution function of p,
otherwise known as the quantile function

<!-- Phi_approx -->
<!-- R; Phi_approx; (T x); -->

`R` **`Phi_approx`**(`T x`)
fast approximation of the unit (may replace `Phi` for probit
regression with maximum absolute error of 0.00014, see
[@BowlingEtAl:2009] for details)

### Other Probability-Related Functions

<!-- binary_log_loss -->
<!-- real; binary_log_loss; (int y, real y_hat); -->

`real` **`binary_log_loss`**(`int y, real y_hat`)
 Returns the log loss function for for predicting $\hat{y} \in [0,1]$
for boolean outcome $y \in \{0,1\}$. \[
\mathrm{binary\_log\_loss}(y,\hat{y}) = \begin{cases} -\log \hat{y} &
\text{if } y = 0\\ -\log (1 - \hat{y}) & \text{otherwise} \end{cases}
\]

<!-- owens_t -->
<!-- real; owens_t; (real h, real a); -->

`real` **`owens_t`**(`real h, real a`)
 Returns the Owen's T function for the probability of the event $X >
h$ and $0<Y<aX$ where X and Y are independent standard normal random
variables. \[ \mathrm{owens\_t}(h,a) = \frac{1}{2\pi} \int_0^a
\frac{\exp(-\frac{1}{2}h^2(1+x^2))}{1+x^2}dx \]

## Combinatorial Functions {#betafun}

<!-- inc_beta -->
<!-- real; inc_beta; (real alpha, real beta, real x); -->

`real` **`inc_beta`**(`real alpha, real beta, real x`)
 Returns the incomplete beta function up to x applied to alpha and
beta. See section \@ref(inc-beta-appendix) for a definition.

<!-- lbeta -->
<!-- real; lbeta; (real alpha, real beta); -->

`real` **`lbeta`**(`real alpha, real beta`)
 Returns the natural logarithm of the beta function applied to alpha
and beta. The beta function, $\text{B}(\alpha,\beta)$, computes the
normalizing constant for the beta distribution, and is defined for
$\alpha > 0$ and $\beta > 0$. \[ \text{lbeta}(\alpha,\beta) = \log
\Gamma(a) + \log \Gamma(b) - \log \Gamma(a+b) \] See section
\@ref(beta-appendix) for definition of $\text{B}(\alpha, \beta)$.

<!-- tgamma -->
<!-- R; tgamma; (T x); -->

`R` **`tgamma`**(`T x`)
gamma function applied to x. The gamma function is the generalization
of the factorial function to continuous variables, defined so that
$\Gamma(n+1) = n!$. See for a full definition of $\Gamma(x)$. The
function is defined for positive numbers and non-integral negative
numbers,

<!-- lgamma -->
<!-- R; lgamma; (T x); -->

`R` **`lgamma`**(`T x`)
natural logarithm of the gamma function applied to x,

<!-- digamma -->
<!-- R; digamma; (T x); -->

`R` **`digamma`**(`T x`)
digamma function applied to x. The digamma function is the derivative
of the natural logarithm of the Gamma function. The function is
defined for positive numbers and non-integral negative numbers

<!-- trigamma -->
<!-- R; trigamma; (T x); -->

`R` **`trigamma`**(`T x`)
trigamma function applied to x. The trigamma function is the second
derivative of the natural logarithm of the Gamma function

<!-- lmgamma -->
<!-- real; lmgamma; (int n, real x); -->

`real` **`lmgamma`**(`int n, real x`)
 Returns the natural logarithm of the multivariate gamma function
$\Gamma_n$ with n dimensions applied to x. \[ \text{lmgamma}(n,x) =
\begin{cases} \frac{n(n-1)}{4} \log \pi + \sum_{j=1}^n \log
\Gamma\left(x + \frac{1 - j}{2}\right) & \text{if } x\not\in
\{\dots,-3,-2,-1,0\}\\ \textrm{error} & \text{otherwise} \end{cases}
\]

<!-- gamma_p -->
<!-- real; gamma_p; (real a, real z); -->

`real` **`gamma_p`**(`real a, real z`)
 Returns the normalized lower incomplete gamma function of a and z
defined for positive a and nonnegative z. \[ \mathrm{gamma\_p}(a,z) =
\begin{cases} \frac{1}{\Gamma(a)}\int_0^zt^{a-1}e^{-t}dt & \text{if }
a > 0, z \geq 0 \\ \textrm{error} & \text{otherwise} \end{cases} \]

<!-- gamma_q -->
<!-- real; gamma_q; (real a, real z); -->

`real` **`gamma_q`**(`real a, real z`)
 Returns the normalized upper incomplete gamma function of a and z
defined for positive a and nonnegative z. \[ \mathrm{gamma\_q}(a,z) =
\begin{cases} \frac{1}{\Gamma(a)}\int_z^\infty t^{a-1}e^{-t}dt &
\text{if } a > 0, z \geq 0 \\[6pt] \textrm{error} & \text{otherwise}
\end{cases} \]

<!-- binomial_coefficient_log -->
<!-- real; binomial_coefficient_log; (real x, real y); -->

`real` **`binomial_coefficient_log`**(`real x, real y`)
 _**Warning:**_ This function is deprecated and should be replaced
with `lchoose`. Returns the natural logarithm of the binomial
coefficient of x and y. For non-negative integer inputs, the binomial
coefficient function is written as $\binom{x}{y}$ and pronounced "x
choose y." This function generalizes to real numbers using the gamma
function. For $0 \leq y \leq x$, \[
\mathrm{binomial\_coefficient\_log}(x,y) = \log\Gamma(x+1) -
\log\Gamma(y+1) - \log\Gamma(x-y+1). \]

<!-- choose -->
<!-- int; choose; (int x, int y); -->

`int` **`choose`**(`int x, int y`)
 Returns the binomial coefficient of x and y. For non-negative integer
inputs, the binomial coefficient function is written as $\binom{x}{y}$
and pronounced "x choose y." In its the antilog of the `lchoose`
function but returns an integer rather than a real number with no
non-zero decimal places. For $0 \leq y \leq x$, the binomial
coefficient function can be defined via the factorial function \[
\text{choose}(x,y) = \frac{x!}{\left(y!\right)\left(x - y\right)!}. \]

<!-- bessel_first_kind -->
<!-- real; bessel_first_kind; (int v, real x); -->

`real` **`bessel_first_kind`**(`int v, real x`)
 Returns the Bessel function of the first kind with order v applied to
x. \[ \mathrm{bessel\_first\_kind}(v,x) = J_v(x), \] where \[
J_v(x)=\left(\frac{1}{2}x\right)^v \sum_{k=0}^\infty
\frac{\left(-\frac{1}{4}x^2\right)^k}{k!\, \Gamma(v+k+1)} \]

<!-- bessel_second_kind -->
<!-- real; bessel_second_kind; (int v, real x); -->

`real` **`bessel_second_kind`**(`int v, real x`)
 Returns the Bessel function of the second kind with order v applied
to x defined for positive x and v. For $x,v > 0$, \[
\mathrm{bessel\_second\_kind}(v,x) = \begin{cases} Y_v(x) & \text{if }
x > 0 \\ \textrm{error} & \text{otherwise} \end{cases} \] where \[
Y_v(x)=\frac{J_v(x)\cos(v\pi)-J_{-v}(x)}{\sin(v\pi)} \]

<!-- modified_bessel_first_kind -->
<!-- real; modified_bessel_first_kind; (int v, real z); -->

`real` **`modified_bessel_first_kind`**(`int v, real z`)
 Returns the modified Bessel function of the first kind with order v
applied to z defined for all z and v. \[
\mathrm{modified\_bessel\_first\_kind}(v,z) = I_v(z) \] where \[
{I_v}(z) = \left(\frac{1}{2}z\right)^v\sum_{k=0}^\infty
\frac{\left(\frac{1}{4}z^2\right)^k}{k!\Gamma(v+k+1)} \]

<!-- modified_bessel_second_kind -->
<!-- real; modified_bessel_second_kind; (int v, real z); -->

`real` **`modified_bessel_second_kind`**(`int v, real z`)
 Returns the modified Bessel function of the second kind with order v
applied to z defined for positive z and v. \[
\mathrm{modified\_bessel\_second\_kind}(v,z) = \begin{cases} K_v(z) &
\text{if } z > 0 \\ \textrm{error} & \text{if } z \leq 0 \end{cases}
\] where \[ {K_v}(z) = \frac{\pi}{2}\cdot\frac{I_{-v}(z) -
I_{v}(z)}{\sin(v\pi)} \]

<!-- falling_factorial -->
<!-- real; falling_factorial; (real x, real n); -->

`real` **`falling_factorial`**(`real x, real n`)
 Returns the falling factorial of x with power n defined for positive
x and real n. \[ \mathrm{falling\_factorial}(x,n) = \begin{cases}
(x)_n & \text{if } x > 0 \\ \textrm{error} & \text{if } x \leq 0
\end{cases} \] where \[ (x)_n=\frac{\Gamma(x+1)}{\Gamma(x-n+1)} \]

<!-- lchoose -->
<!-- real; lchoose; (real x, real y); -->

`real` **`lchoose`**(`real x, real y`)
 Returns the natural logarithm of the generalized binomial coefficient
of x and y. For non-negative integer inputs, the binomial coefficient
function is written as $\binom{x}{y}$ and pronounced "x choose y."
This function generalizes to real numbers using the gamma function.
For $0 \leq y \leq x$, \[ \mathrm{binomial\_coefficient\_log}(x,y) =
\log\Gamma(x+1) - \log\Gamma(y+1) - \log\Gamma(x-y+1). \]

<!-- log_falling_factorial -->
<!-- real; log_falling_factorial; (real x, real n); -->

`real` **`log_falling_factorial`**(`real x, real n`)
 Returns the log of the falling factorial of x with power n defined
for positive x and real n. \[ \mathrm{log\_falling\_factorial}(x,n) =
\begin{cases} \log (x)_n & \text{if } x > 0 \\ \textrm{error} &
\text{if } x \leq 0 \end{cases} \]

<!-- rising_factorial -->
<!-- real; rising_factorial; (real x, real n); -->

`real` **`rising_factorial`**(`real x, real n`)
 Returns the rising factorial of x with power n defined for positive x
and real n. \[ \mathrm{rising\_factorial}(x,n) = \begin{cases} x^{(n)}
& \text{if } x > 0 \\ \textrm{error} & \text{if } x \leq 0 \end{cases}
\] where \[ x^{(n)}=\frac{\Gamma(x+n)}{\Gamma(x)} \]

<!-- log_rising_factorial -->
<!-- real; log_rising_factorial; (real x, real n); -->

`real` **`log_rising_factorial`**(`real x, real n`)
 Returns the log of the rising factorial of x with power n defined for
positive x and real n. \[ \mathrm{log\_rising\_factorial}(x,n) =
\begin{cases} \log x^{(n)} & \text{if } x > 0 \\ \textrm{error} &
\text{if } x \leq 0 \end{cases} \]

## Composed Functions {#composed-functions}

The functions in this section are equivalent in theory to combinations
of other functions.  In practice, they are implemented to be more
efficient and more numerically stable than defining them directly
using more basic Stan functions.

<!-- expm1 -->
<!-- R; expm1; (T x); -->

`R` **`expm1`**(`T x`)
natural exponential of x minus 1

<!-- fma -->
<!-- real; fma; (real x, real y, real z); -->

`real` **`fma`**(`real x, real y, real z`)
 Returns z plus the result of x multiplied by y. \[ \text{fma}(x,y,z)
= (x \times y) + z \]

<!-- multiply_log -->
<!-- real; multiply_log; (real x, real y); -->

`real` **`multiply_log`**(`real x, real y`)
 _**Warning:**_ This function is deprecated and should be replaced
with `lmultiply`. Returns the product of x and the natural logarithm
of y. \[ \mathrm{multiply\_log}(x,y) = \begin{cases} 0 & \text{if } x
= y = 0 \\ x \log y & \text{if } x, y \neq 0 \\ \text{NaN} &
\text{otherwise} \end{cases} \]

<!-- lmultiply -->
<!-- real; lmultiply; (real x, real y); -->

`real` **`lmultiply`**(`real x, real y`)
 Returns the product of x and the natural logarithm of y. \[
\text{lmultiply}(x,y) = \begin{cases} 0 & \text{if } x = y = 0 \\ x
\log y & \text{if } x, y \neq 0 \\ \text{NaN} & \text{otherwise}
\end{cases} \]

<!-- log1p -->
<!-- R; log1p; (T x); -->

`R` **`log1p`**(`T x`)
natural logarithm of 1 plus x

<!-- log1m -->
<!-- R; log1m; (T x); -->

`R` **`log1m`**(`T x`)
natural logarithm of 1 minus x

<!-- log1p_exp -->
<!-- R; log1p_exp; (T x); -->

`R` **`log1p_exp`**(`T x`)
natural logarithm of one plus the natural exponentiation of x

<!-- log1m_exp -->
<!-- R; log1m_exp; (T x); -->

`R` **`log1m_exp`**(`T x`)
logarithm of one minus the natural exponentiation of x

<!-- log_diff_exp -->
<!-- real; log_diff_exp; (real x, real y); -->

`real` **`log_diff_exp`**(`real x, real y`)
 Returns the natural logarithm of the difference of the natural
exponentiation of x and the natural exponentiation of y. \[
\mathrm{log\_diff\_exp}(x,y) = \begin{cases} \log(\exp(x)-\exp(y)) &
\text{if } x > y \\[6pt] \textrm{NaN} & \text{otherwise} \end{cases}
\]

<!-- log_mix -->
<!-- real; log_mix; (real theta, real lp1, real lp2); -->

`real` **`log_mix`**(`real theta, real lp1, real lp2`)
 Returns the log mixture of the log densities lp1 and lp2 with mixing
proportion theta, defined by \begin{eqnarray*}
\mathrm{log\_mix}(\theta, \lambda_1, \lambda_2) & = & \log \!\left(
\theta \exp(\lambda_1) + \left( 1 - \theta \right) \exp(\lambda_2)
\right) \\[3pt] & = & \mathrm{log\_sum\_exp}\!\left(\log(\theta) +
\lambda_1, \ \log(1 - \theta) + \lambda_2\right). \end{eqnarray*}

<!-- log_sum_exp -->
<!-- real; log_sum_exp; (real x, real y); -->

`real` **`log_sum_exp`**(`real x, real y`)
 Returns the natural logarithm of the sum of the natural
exponentiation of x and the natural exponentiation of y. \[
\mathrm{log\_sum\_exp}(x,y) = \log(\exp(x)+\exp(y)) \]

<!-- log_inv_logit -->
<!-- R; log_inv_logit; (T x); -->

`R` **`log_inv_logit`**(`T x`)
natural logarithm of the inverse logit function of x

<!-- log1m_inv_logit -->
<!-- R; log1m_inv_logit; (T x); -->

`R` **`log1m_inv_logit`**(`T x`)
natural logarithm of 1 minus the inverse logit function of x

